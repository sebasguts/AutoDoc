<Chapter Label="Comments">
<Heading>&AutoDoc; documentation comments</Heading>

You can document declarations of global functions and variables, operations,
attributes etc. by inserting &AutoDoc; comments into your sources before these declaration.
An &AutoDoc; comment always starts with <C>#!</C>. This is also the smallest possible
&AutoDoc; command. If you want your declaration documented, just write
<C>#!</C> at the line before the documentation. For example:

<Listing><![CDATA[
#!
DeclareOperation( "AnOperation",
                  [ IsList ] );
]]></Listing>

This will produce a manual entry for the operation <C>AnOperation</C>.


<Section>
<Heading>Documenting declarations</Heading>

In the bare form above, the manual entry for <C>AnOperation</C> will not
contain much more than the name of the operation. In order to change
this, there are several commands you can put into the &AutoDoc; comment
before the declaration. Currently, the following commands are provided:

<Subsection Label="@Description">
<Index Key="@Description"><C>@Description</C></Index>
<Heading>@Description <A>descr</A></Heading>
Adds the text in the following lines of the &AutoDoc; to the description
of the declaration in the manual. Lines are until the next &AutoDoc; command
or until the declaration is reached.
</Subsection>

<Subsection Label="@Returns">
<Index Key="@Returns"><C>@Returns</C></Index>
<Heading>@Returns <A>ret_val</A></Heading>
The string <A>ret_val</A> is added to the documentation, with the text <Q>Returns: </Q>
put in front of it. This should usually give a brief hint about the type or meaning
of the value retuned by the documented function.
</Subsection>

<Subsection Label="@Arguments">
<Index Key="@Arguments"><C>@Arguments</C></Index>
<Heading>@Arguments <A>args</A></Heading>
The string <A>args</A> contains a description of the arguments the
function expects, including optional parts, which are denoted by square
brackets. The argument names can be separated by whitespace, commas or
square brackets for the optional arguments, like <Q>grp[, elm]</Q> or
<Q>xx[y[z] ]</Q>. If &GAP; options are used, this can be followed by a colon :
and one or more assignments, like <Q>n[, r]: tries := 100</Q>.
</Subsection>

<Subsection Label="@Group">
<Index Key="@Group"><C>@Group</C></Index>
<Heading>@Group <A>grpname</A></Heading>
Adds the following method to a group with the given name.
See section <Ref Sect="Groups"/> for more information about groups.
</Subsection>

<Subsection Label="@FunctionLabel">
<Index Key="@FunctionLabel"><C>@FunctionLabel</C></Index>
<Heading>@FunctionLabel <A>label</A></Heading>
Adds label to the function as label.

If this is not specified, then for declarations that involve a list of input filters
(as is the case for <C>DeclareOperation</C>, <C>DeclareAttribute</C>, etc.),
a default label is generated from this filter list.
<!-- TODO: Give an example of this, i.e. some input and ALSO the resulting output -->
</Subsection>

<Subsection Label="@ChapterInfo">
<Index Key="@ChapterInfo"><C>@ChapterInfo</C></Index>
<Heading>@ChapterInfo <A>chapter, section</A></Heading>
Adds the entry to the given chapter and section. Here,
<A>chapter</A> and <A>section</A> are the respective
titles.
</Subsection>


As an example, a full &AutoDoc; comment for with all options could look like this:

<Listing><![CDATA[
#! @Description
#! Computes the list of lists of degrees of ordinary characters
#! associated to the <A>p</A>-blocks of the group <A>G</A>
#! with <A>p</A>-modular character table <A>modtbl</A>
#! and underlying ordinary character table <A>ordtbl</A>.
#! @Returns a list
#! @Arguments modtbl
#! @Group CharacterDegreesOfBlocks
#! @FunctionLabel chardegblocks
#! @ChapterInfo Blocks, Attributes
DeclareAttribute( "CharacterDegreesOfBlocks",
        IsBrauerTable );
]]></Listing>

</Section>

<Section>
<Heading>Other documentation comments</Heading>

There are also some commands which can be used in &AutoDoc; comments
that are not associated to any declaration.

<Subsection Label="@Chapter">
<Index Key="@Chapter"><C>@Chapter</C></Index>
<Heading>@Chapter <A>name</A></Heading>
Sets a chapter, all functions without seperate info will be added to this chapter.
Also all text comments, i.e. lines that begin with #! without a command, and which do not
follow after @description, will be added to the chapter as regular text.

Example:

<Listing><![CDATA[
#! @Chapter My chapter
#!  This is my chapter.
#!  I document my stuff in it.
]]></Listing>
</Subsection>

<Subsection Label="@Section">
<Index Key="@Section"><C>@Section</C></Index>
<Heading>@Section <A>name</A></Heading>
Sets a section like chapter sets a chapter.

<Listing><![CDATA[
#! @Section My first manual section
#!  In this section I am going to document my first method.
]]></Listing>
</Subsection>

<Subsection Label="@EndSection">
<Index Key="@EndSection"><C>@EndSection</C></Index>
<Heading>@EndSection</Heading>
Closes the current section.

<Listing><![CDATA[
#! @EndSection
#### The following text again belongs to the chapter
#! Now we have a second section.
]]></Listing>
</Subsection>

<Subsection Label="@AutoDoc">
<Index Key="@AutoDoc"><C>@AutoDoc</C></Index>
<Heading>@AutoDoc</Heading>

Causes all subsequent declarations to be documented in the manual,
regardless of whether they have an &AutoDoc; comment in front of
them or not.
</Subsection>

<Subsection Label="@EndAutoDoc">
<Index Key="@EndAutoDoc"><C>@EndAutoDoc</C></Index>
<Heading>@EndAutoDoc</Heading>
Ends the affect of <C>@AutoDoc</C>. So from here on, again only declarations
with an explicit &AutoDoc; comment in front are added to the manual.

<Listing><![CDATA[
#! @AutoDoc

DeclareOperation( "Operation1", [ IsList ] );

DeclareProperty( "IsProperty", IsList );

#! @EndAutoDoc
]]></Listing>
</Subsection>

<Subsection Label="@BeginGroup">
<Index Key="@BeginGroup"><C>@BeginGroup</C></Index>
<Heading>@BeginGroup <A>[grpname]</A></Heading>
Starts a group. All following documented declarations without an
explicit <C>@Group</C> command are grouped together in the same group
with the given name. If no name is given, then a new nameless group is
generated.
The effect of this command is ended when an <C>@EndGroup</C> command
is reached.
<P/>

See section <Ref Sect="Groups"/> for more information about groups.
</Subsection>

<Subsection Label="@EndGroup">
<Index Key="@EndGroup"><C>@EndGroup</C></Index>
<Heading>@EndGroup</Heading>
Ends the current group.

<Listing><![CDATA[
#! @BeginGroup MyGroup
#!
DeclareAttribute( "GroupedAttribute",
                  IsList );

DeclareOperation( "NonGroupedOperation",
                  [ IsObject ] );

#!
DeclareOperation( "GroupedOperation",
                  [ IsList, IsRubbish ] );
#! @EndGroup
]]></Listing>
</Subsection>

</Section>

<Section Label="Groups">
<Heading>Grouping</Heading>

TODO: explain more about groups and what they do, how they look in the
generated output etc.
<P/>

Note that group names are globally unique throughout the whole manual.
That is, groups with the same name are in fact merged into a single group, even if they
were declared in different source files.
Thus you can have multiple <C>@BeginGroup</C> / <C>@EndGroup</C> pairs using the
same group name, in different places, and these all will refer to the same group.
<P/>

Moreover, this means that you can add items to a group via the <C>@Group</C> command
in the &AutoDoc; comment of an arbitrary declaration, at any time.


</Section>

</Chapter>
